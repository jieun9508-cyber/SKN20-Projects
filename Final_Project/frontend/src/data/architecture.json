[
  {
    "problem_id": "jr_001_url_shortener",
    "title": "축제 홍보용 단축 URL 생성기",
    "scenario": "학생회에서 축제 홍보용 긴 구글 폼 링크를 짧은 URL로 변환하여 배포하려고 합니다. 홍보 문자가 발송되는 시점에 대량의 클릭이 발생합니다.",
    "engineering_spec": {
      "traffic": "하루 평균 1,000개 생성, 읽기 요청은 초당 최대 1,000건(TPS)",
      "latency": "리다이렉션 응답 속도 100ms 이내",
      "storage": "생성된 링크는 1년간 영구 보존",
      "constraints": "동일한 긴 URL에 대해 매번 다른 단축 URL을 생성해야 함"
    },
    "mission": [
      "초당 수천 건의 읽기 요청을 처리하면서 DB 부하를 최소화하는 구조를 설계하세요.",
      "단축 URL 생성 및 원본 리다이렉션의 데이터 흐름을 다이어그램으로 나타내세요."
    ],
    "rubric_functional": {
      "required_components": ["Web Server", "RDBMS", "Cache (Redis)"],
      "required_flows": [
        {"from": "Web Server", "to": "Cache", "reason": "단축 URL 키로 원본 URL 우선 조회 (Read-through)"},
        {"from": "Cache", "to": "RDBMS", "reason": "캐시 미스 시 DB 조회 및 결과 캐싱"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Scalability",
        "question_intent": "캐시 계층의 위치와 역할",
        "model_answer": "서버와 DB 사이에 Redis를 배치하여 읽기 성능을 높이고 DB I/O 병목을 해결하는 구조를 그려야 함"
      }
    ]
  },
  {
    "problem_id": "jr_002_pastebin",
    "title": "동아리 에러 로그 공유함 (Pastebin)",
    "scenario": "개발 동아리에서 긴 에러 로그를 텍스트로 업로드하고 링크로 공유하는 서비스를 만듭니다. 텍스트 본문이 매우 커서 일반적인 DB 저장 방식은 한계가 있습니다.",
    "engineering_spec": {
      "traffic": "일일 업로드 5,000건, 조회 50,000건",
      "storage_size": "텍스트 본문 최대 10MB",
      "data_policy": "7일 후 자동 만료 및 삭제 처리",
      "resources": "DB 저장 공간 비용을 최소화해야 함"
    },
    "mission": [
      "대용량 텍스트 데이터와 메타데이터의 저장소를 분리하여 설계하세요.",
      "만료된 데이터를 효율적으로 정리하는 컴포넌트를 배치하세요."
    ],
    "rubric_functional": {
      "required_components": ["Web Server", "Object Storage (S3)", "RDBMS", "Cleanup Worker"],
      "required_flows": [
        {"from": "Web Server", "to": "Object Storage", "reason": "무거운 로그 본문(File) 저장"},
        {"from": "Web Server", "to": "RDBMS", "reason": "파일 경로(URL) 및 만료 시간만 저장"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Storage Strategy",
        "question_intent": "데이터 성격에 따른 저장소 이원화",
        "model_answer": "RDBMS에는 검색용 인덱스만 두고, 실제 본문은 스토리지에 저장하는 '분리 구조'가 명시되어야 함"
      }
    ]
  },
  {
    "problem_id": "jr_003_notification",
    "title": "오늘의 학식 점심 알림",
    "scenario": "매일 점심 11시 30분에 전교생 1만 명에게 동시에 푸시 알림을 보냅니다. 알림 발송 순간 메인 서버가 멈추는 현상이 발생하고 있습니다.",
    "engineering_spec": {
      "peak_traffic": "오전 11:30에 10,000건의 알림 요청 집중",
      "latency": "전송에 1~2분 정도의 지연은 허용됨",
      "reliability": "알림 전송 실패 시 반드시 재시도 로직이 동작해야 함",
      "resources": "메인 웹 서버의 가용성이 알림 작업에 영향을 받지 않아야 함"
    },
    "mission": [
      "트래픽 폭주(Spike)를 완충할 수 있는 비동기 메시징 시스템을 설계하세요.",
      "서버와 발송 로직의 결합도를 낮추는 구조를 그리세요."
    ],
    "rubric_functional": {
      "required_components": ["Web Server", "Message Queue (Kafka/RabbitMQ)", "Notification Worker"],
      "required_flows": [
        {"from": "Web Server", "to": "Message Queue", "reason": "발송 요청을 큐에 적재하여 서버 부하 방지"},
        {"from": "Message Queue", "to": "Worker", "reason": "워커가 가용량에 맞춰 순차적으로 메시지 소비"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Reliability",
        "question_intent": "비동기 처리를 통한 시스템 안정성 확보",
        "model_answer": "메시지 큐를 완충 지대로 활용하여 생산자와 소비자 간의 속도 차이를 조절하는 구조를 그려야 함"
      }
    ]
  },
  {
    "problem_id": "jr_004_image_feed",
    "title": "반려 식물 성장 일기 (이미지 피드)",
    "scenario": "사용자들이 고화질 식물 사진을 업로드하고 피드를 통해 공유합니다. 전 세계 어디서든 사진이 빠르게 로딩되어야 합니다.",
    "engineering_spec": {
      "image_size": "평균 5MB 내외의 고화질 이미지",
      "latency": "이미지 로딩 지연 시간 500ms 이내",
      "traffic": "전 세계 각지에서 동시 접속",
      "costs": "원본 서버의 대역폭 사용료 절감 필요"
    },
    "mission": [
      "정적 콘텐츠 전송 성능을 극대화하고 서버 부하를 줄이는 캐싱 구조를 설계하세요.",
      "이미지 조회 시 데이터가 흐르는 경로를 최적화하세요."
    ],
    "rubric_functional": {
      "required_components": ["Object Storage", "CDN", "Web Server", "Database"],
      "required_flows": [
        {"from": "Client", "to": "CDN", "reason": "지리적으로 가까운 엣지 서버에서 캐시된 이미지 조회"},
        {"from": "CDN", "to": "Object Storage", "reason": "캐시 미스 시 원본 스토리지에서 데이터 로드"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Performance",
        "question_intent": "엣지 컴퓨팅 및 CDN 활용",
        "model_answer": "사용자와 원본 서버 사이에 CDN을 배치하여 물리적 거리로 인한 지연을 해결하는 구조가 포함되어야 함"
      }
    ]
  },
  {
    "problem_id": "jr_005_concurrency",
    "title": "인기 교양 과목 수강 신청",
    "scenario": "정원이 50명인 과목에 수백 명이 동시 클릭을 시도합니다. 시스템 오류로 인해 정원이 초과되는 상황을 방지해야 합니다.",
    "engineering_spec": {
      "peak_traffic": "9:00~9:01 사이 초당 1,000건 이상의 요청(TPS)",
      "capacity": "정확히 50명까지만 성공 처리",
      "resources": "사용 가능한 서버는 최대 3대로 제한 (Scale-out 제한)",
      "integrity": "0.01초 차이의 선착순 순서를 보장해야 함"
    },
    "mission": [
      "여러 대의 서버가 동시에 접근해도 데이터 일관성을 유지하는 제어 구조를 설계하세요.",
      "DB 부하를 분산하면서도 정확한 카운팅이 가능한 기술을 배치하세요."
    ],
    "rubric_functional": {
      "required_components": ["Web Server", "Redis (Distributed Lock/Atomic)", "RDBMS"],
      "required_flows": [
        {"from": "Web Server", "to": "Redis", "reason": "메모리 상에서 실시간 정원 차감 및 중복 체크"},
        {"from": "Web Server", "to": "RDBMS", "reason": "최종 성공 내역을 비동기 또는 트랜잭션으로 기록"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Data Integrity",
        "question_intent": "분산 환경의 동시성 제어",
        "model_answer": "서버 개별 로직이 아닌 Redis 같은 중앙 집중식 저장소에서 상태를 관리하여 레이스 컨디션을 방지하는 구조를 그려야 함"
      }
    ]
  },
  {
    "problem_id": "jr_006_chat",
    "title": "교내 멘토링 1:1 실시간 채팅",
    "scenario": "멘토와 멘티가 실시간으로 상담을 진행합니다. 카카오톡처럼 새로고침 없이 메시지가 즉각 전달되어야 합니다.",
    "engineering_spec": {
      "latency": "메시지 전달 지연 200ms 이내",
      "concurrency": "동시 접속자 1,000명 유지",
      "connectivity": "안정적인 양방향 실시간 연결 보장",
      "reliability": "상대방이 오프라인일 때도 메시지 유실 금지"
    },
    "mission": [
      "상태 유지(Stateful) 연결을 효율적으로 관리하는 서버 구조를 설계하세요.",
      "채팅 서버가 여러 대일 때 사용자 간 메시지를 라우팅하는 방안을 포함하세요."
    ],
    "rubric_functional": {
      "required_components": ["WebSocket Gateway", "Pub/Sub (Redis)", "RDBMS"],
      "required_flows": [
        {"from": "Client", "to": "WebSocket Gateway", "reason": "지속적인 양방향 세션 유지"},
        {"from": "WebSocket Gateway", "to": "Pub/Sub", "reason": "다른 서버에 연결된 사용자에게 메시지 전파"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Availability",
        "question_intent": "서버 간 메시지 브로드캐스팅",
        "model_answer": "분산된 채팅 서버 간 데이터 교환을 위해 중간에 메시지 브로커(Redis Pub/Sub 등)를 두는 구조가 나타나야 함"
      }
    ]
  },
  {
    "problem_id": "jr_007_newsfeed",
    "title": "동아리 통합 공지 뉴스피드",
    "scenario": "사용자가 가입한 여러 동아리의 소식을 모아보는 타임라인입니다. 읽기 요청이 쓰기 요청보다 100배 이상 많습니다.",
    "engineering_spec": {
      "read_write_ratio": "Read 100 : Write 1",
      "latency": "뉴스피드 로딩 시간 200ms 이내",
      "scalability": "동아리당 최대 가입자 500명 내외",
      "constraints": "조회 시점에 매번 복잡한 Table Join을 수행하면 안 됨"
    },
    "mission": [
      "뉴스피드 조회 성능을 최적화하기 위해 데이터를 미리 구성(Pre-computing)하는 구조를 설계하세요.",
      "사용자별 피드 캐시를 관리하는 컴포넌트를 배치하세요."
    ],
    "rubric_functional": {
      "required_components": ["Feed Service", "Newsfeed Cache (Redis)", "Database"],
      "required_flows": [
        {"from": "Feed Service", "to": "Newsfeed Cache", "reason": "사용자별로 미리 계산된 피드 목록 즉시 반환"},
        {"from": "Web Server", "to": "Database", "reason": "게시글 작성 시 원본 저장"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Performance",
        "question_intent": "Fan-out 전략 (Pull vs Push)",
        "model_answer": "데이터를 읽을 때가 아니라 쓸 때 미리 피드를 만들어 두거나 캐싱하는 구조가 다이어그램에 포함되어야 함"
      }
    ]
  },
  {
    "problem_id": "jr_008_autocomplete",
    "title": "도서관 도서 검색 자동완성",
    "scenario": "검색창에 한 글자만 입력해도 실시간으로 도서 제목이 추천됩니다. 수만 권의 도서 목록에서 초고속 검색이 필요합니다.",
    "engineering_spec": {
      "latency": "타이핑마다 응답 속도 50ms 이내",
      "traffic": "초당 최대 500건의 검색 요청",
      "storage_size": "약 5만 권의 도서 제목 데이터",
      "constraints": "RDBMS의 LIKE 검색 사용 금지"
    },
    "mission": [
      "접두사(Prefix) 검색에 특화된 전용 검색 엔진이나 자료구조 서버를 배치하세요.",
      "메인 DB의 부하를 주지 않고 검색 요청을 처리하는 구조를 설계하세요."
    ],
    "rubric_functional": {
      "required_components": ["Search API", "In-memory Search Engine (Trie/Redis/ES)", "Database"],
      "required_flows": [
        {"from": "Client", "to": "Search API", "reason": "키 입력 시마다 자동완성 요청 발송"},
        {"from": "Search API", "to": "Search Engine", "reason": "인메모리 인덱스에서 추천어 즉시 조회"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Scalability",
        "question_intent": "검색 전용 저장소 독립",
        "model_answer": "RDBMS와 별개로 검색 성능에 최적화된 컴포넌트(Trie 구조 기반 서버 등)를 그려야 함"
      }
    ]
  },
  {
    "problem_id": "jr_009_geolocation",
    "title": "셔틀버스 실시간 위치 추적",
    "scenario": "학교 셔틀버스의 위치를 지도 앱에서 실시간으로 확인합니다. 버스는 계속 움직이며 위치 정보를 서버로 보냅니다.",
    "engineering_spec": {
      "write_frequency": "버스당 3초마다 위경도 좌표 업데이트",
      "traffic": "동시 지도 접속자 3,000명",
      "latency": "위치 갱신 지연 1초 이내",
      "storage": "운행 기록은 하루 단위로 백업"
    },
    "mission": [
      "빈번한 위치 정보 갱신(Write-Heavy)을 처리하는 고성능 쓰기 계층을 설계하세요.",
      "실시간 위치 정보와 히스토리 데이터를 분리하여 관리하는 구조를 그리세요."
    ],
    "rubric_functional": {
      "required_components": ["Location API", "In-memory Store (Redis Geo)", "History DB (RDBMS)"],
      "required_flows": [
        {"from": "Bus", "to": "Location API", "reason": "빈번한 위경도 좌표 전송"},
        {"from": "Location API", "to": "Redis", "reason": "현재 위치 실시간 업데이트 및 Geo-indexing"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Performance",
        "question_intent": "Write 집약적 작업 분리",
        "model_answer": "매번 DB에 저장하지 않고 인메모리에서 실시간 위치를 처리하는 '레이어 분리' 구조를 그려야 함"
      }
    ]
  },
  {
    "problem_id": "jr_010_webcrawler",
    "title": "취업 공고 통합 크롤러",
    "scenario": "외부 취업 사이트들의 공고를 자동으로 수집하여 교내 게시판에 통합 제공합니다. 이미 수집한 공고를 중복해서 가져오는 낭비를 막아야 합니다.",
    "engineering_spec": {
      "traffic": "일일 수집 대상 URL 10만 건 이상",
      "efficiency": "중복 체크 시 메모리 사용량을 최소화해야 함",
      "politeness": "대상 서버에 무리를 주지 않도록 요청 속도 조절",
      "scalability": "여러 대의 워커가 분산하여 수집 진행"
    },
    "mission": [
      "분산 크롤링을 위한 작업 큐와 중복 체크 컴포넌트를 배치하세요.",
      "수집된 데이터가 저장되기까지의 파이프라인을 설계하세요."
    ],
    "rubric_functional": {
      "required_components": ["Crawler Worker", "Task Queue", "Bloom Filter (Deduplicator)", "Database"],
      "required_flows": [
        {"from": "Task Queue", "to": "Crawler Worker", "reason": "수집 임무 할당"},
        {"from": "Crawler Worker", "to": "Bloom Filter", "reason": "방문 전 중복 여부 초고속 판별"}
      ]
    },
    "rubric_non_functional": [
      {
        "category": "Efficiency",
        "question_intent": "필터링 컴포넌트 위치",
        "model_answer": "DB 조회 전 메모리 상에서 중복을 걸러주는 고효율 필터 계층이 다이어그램에 포함되어야 함"
      }
    ]
  }
]