# 시스템 아키텍처 프랙티스 고도화 방안

## 현재 상태 분석

### 현재 기능 요약
| 항목 | 현황 |
|------|------|
| 문제 수 | 10개 (URL Shortener ~ Web Crawler) |
| 설계 방식 | 드래그&드롭 컴포넌트 배치 + 연결선 |
| 평가 방식 | LLM 기반 6대 기둥 평가 (신뢰성/성능/운영/비용/보안/지속가능성) |
| 시각화 | Mermaid 다이어그램 생성 |
| 코드 에디터 | Monaco Editor (의존성 존재하나 아키텍처 프랙티스에서는 미사용) |

### 현재 한계점
1. **설계만 하고 끝** - 다이어그램을 그리지만 실제 동작을 확인할 수 없음
2. **추상적 평가** - LLM 피드백이 텍스트 기반이라 체감이 약함
3. **실패 경험 부재** - 잘못된 설계가 어떤 문제를 일으키는지 직접 보지 못함
4. **학습 깊이 제한** - 이론적 이해에 머물고 구현 레벨의 이해로 연결되지 않음

---

## 핵심 고도화 제안: "Architecture Live Playground"

### 개념
사용자가 설계한 아키텍처를 기반으로, 해당 시스템의 핵심 동작을 **브라우저에서 바로 시뮬레이션**할 수 있는 인터랙티브 프로토타입을 새 창으로 띄워 테스트하게 한다.

### 접근 방식 비교

| 방식 | 설명 | 장점 | 단점 | 난이도 |
|------|------|------|------|--------|
| **A. 템플릿 기반 시뮬레이터** | 문제별 미리 만든 Vue 컴포넌트 | 완성도 높음, 안정적 | 10개 문제 각각 제작 필요 | 높음 |
| **B. LLM 코드 생성 + iframe** | LLM이 standalone HTML 생성 → 새 창 | 유연함, 확장 쉬움 | 결과 품질 불안정 | 중간 |
| **C. 하이브리드 (추천)** | 템플릿 골격 + LLM이 사용자 설계 반영 | 안정성+맞춤화 균형 | 초기 구현 복잡 | 중~높 |

### 추천: C안 (하이브리드 방식)

---

## 상세 설계

### 1. 전체 아키텍처

```
[사용자 아키텍처 설계 완료]
        ↓
[시뮬레이션 버튼 클릭]
        ↓
[SimulationGenerator 서비스]
  ├─ 사용자의 컴포넌트/연결 정보 수집
  ├─ 문제 유형별 템플릿 선택
  ├─ (선택적) LLM이 사용자 설계에 맞게 커스터마이징
  └─ standalone HTML+CSS+JS 코드 생성
        ↓
[새 브라우저 창 (window.open)]
  └─ Blob URL로 생성된 HTML 렌더링
        ↓
[사용자가 인터랙티브하게 테스트]
  ├─ 요청 전송 버튼
  ├─ 부하 시뮬레이션
  ├─ 실시간 메트릭 대시보드
  └─ 컴포넌트 간 데이터 흐름 애니메이션
```

### 2. 새 창 렌더링 기술 방식

```javascript
// 핵심 구현 원리
function openSimulation(htmlCode) {
  const blob = new Blob([htmlCode], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  const win = window.open(url, '_blank', 'width=1200,height=800');

  // 메모리 해제
  win.addEventListener('beforeunload', () => URL.revokeObjectURL(url));
}
```

- Blob URL 방식으로 별도 서버 불필요
- 독립적인 HTML 문서로 Vue/React 의존성 없이 동작
- TailwindCSS CDN 포함하여 스타일링
- 새 창이므로 기존 프랙티스 화면과 독립적

### 3. 문제별 시뮬레이션 설계

---

#### 문제 1: 축제 홍보용 단축 URL 생성기

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [URL 단축기 시뮬레이터]                              │
│                                                      │
│  ┌──────────────────────────┐                        │
│  │ 긴 URL 입력: [________] │  [단축!]               │
│  │ 결과: https://short/abc  │                        │
│  └──────────────────────────┘                        │
│                                                      │
│  [부하 테스트] ── 동시 1000건 요청 시작 ──            │
│                                                      │
│  ┌─ 실시간 메트릭 ──────────────────────────┐        │
│  │ Cache Hit Rate: ████████░░ 82%           │        │
│  │ Avg Response:   45ms (캐시) / 230ms (DB) │        │
│  │ DB Queries:     180건 (캐시 없으면 1000건)│        │
│  └──────────────────────────────────────────┘        │
│                                                      │
│  ┌─ 데이터 흐름 애니메이션 ─────────────────┐        │
│  │ Client ──→ Server ──→ [Cache ✓] ──→ 응답 │        │
│  │ Client ──→ Server ──→ [Cache ✗] ──→ DB   │        │
│  └──────────────────────────────────────────┘        │
│                                                      │
│  ⚡ 비교: 캐시 있을 때 vs 없을 때 응답시간 차트      │
└─────────────────────────────────────────────────────┘
```

**핵심 학습 포인트:**
- Cache Hit/Miss 시각화로 Redis의 역할 체감
- DB 부하 비교로 캐시 계층의 필요성 직관적 이해
- TPS 그래프로 처리량 한계 확인

---

#### 문제 2: 동아리 에러 로그 공유함 (Pastebin)

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [Pastebin 시뮬레이터]                                │
│                                                      │
│  ┌──────────────────────┐  ┌──────────────────────┐  │
│  │ 텍스트 입력           │  │ 저장소 상태           │  │
│  │ [textarea 10MB]      │  │ DB: 메타 120건/12KB  │  │
│  │                      │  │ S3: 본문 120건/480MB │  │
│  │ [업로드]  [공유링크]  │  │ 절감율: 96%          │  │
│  └──────────────────────┘  └──────────────────────┘  │
│                                                      │
│  ┌─ 비교 실험 ──────────────────────────────┐        │
│  │ [모든것을 DB에 저장] vs [메타/본문 분리]   │        │
│  │ DB 비용: $150/월  vs  DB $3 + S3 $12/월  │        │
│  │ 조회속도: 2.3s     vs  메타 15ms + 본문    │        │
│  └──────────────────────────────────────────┘        │
│                                                      │
│  ┌─ TTL 만료 시뮬레이션 (타임라인) ─────────┐        │
│  │ [7일 경과 ▶] → Cleanup Worker 실행 → 삭제│        │
│  └──────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────┘
```

**핵심 학습 포인트:**
- 저장소 분리의 비용 효과를 숫자로 직접 확인
- TTL 기반 정리 프로세스 시각화

---

#### 문제 3: 오늘의 학식 점심 알림

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [알림 시스템 시뮬레이터]                              │
│                                                      │
│  [동기 발송]        vs        [비동기 발송 (큐)]      │
│                                                      │
│  ┌─ 동기 모드 ────────┐  ┌─ 비동기 모드 ────────┐    │
│  │ 서버 CPU: ████ 98% │  │ 서버 CPU: ██░░ 35%  │    │
│  │ 응답시간: 타임아웃  │  │ 응답시간: 50ms       │    │
│  │ 웹 요청: ❌ 차단됨  │  │ 웹 요청: ✅ 정상     │    │
│  │ 발송완료: 3,200건   │  │ 큐 대기: 6,800건    │    │
│  │ 실패: 6,800건      │  │ Worker 처리중...     │    │
│  └────────────────────┘  └────────────────────────┘  │
│                                                      │
│  [10,000건 알림 발송 시작!]                           │
│                                                      │
│  ┌─ 메시지 큐 시각화 ──────────────────────┐         │
│  │ Producer ══▶ [|||||||||||] ══▶ Consumer  │         │
│  │              Queue: 4,521건              │         │
│  │              처리속도: 200건/초           │         │
│  └─────────────────────────────────────────┘         │
└─────────────────────────────────────────────────────┘
```

**핵심 학습 포인트:**
- 동기 vs 비동기의 서버 부하 차이를 실시간으로 비교
- 메시지 큐가 트래픽 스파이크를 흡수하는 과정 시각화
- 메인 서버의 가용성 차이 직접 체감

---

#### 문제 4: 반려 식물 성장 일기 (이미지 피드)

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [이미지 CDN 시뮬레이터]                              │
│                                                      │
│  ┌─ 세계 지도 ──────────────────────────────┐        │
│  │    🇺🇸 LA      🇰🇷 Seoul     🇩🇪 Berlin   │        │
│  │    CDN Edge    Origin      CDN Edge     │        │
│  │    [12ms]      [---]       [18ms]       │        │
│  └──────────────────────────────────────────┘        │
│                                                      │
│  [이미지 3x3 그리드]                                  │
│  ┌─────┐ ┌─────┐ ┌─────┐                            │
│  │ 🌱  │ │ 🌿  │ │ 🌻  │ ← 로딩 시간 표시          │
│  │ 45ms│ │ 52ms│ │ 38ms│    (CDN 캐시)              │
│  └─────┘ └─────┘ └─────┘                            │
│                                                      │
│  ⚡ CDN 없이 로딩: 평균 1,200ms                       │
│  ⚡ CDN 사용 시:   평균 45ms (96% 개선)               │
│  💰 대역폭 절감:  Origin 트래픽 92% 감소              │
└─────────────────────────────────────────────────────┘
```

---

#### 문제 5: 인기 교양 과목 수강 신청

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [수강신청 동시성 시뮬레이터]                          │
│                                                      │
│  정원: 50명 / 신청자: 500명                           │
│                                                      │
│  [락 없이 실행]      vs      [분산 락 사용]           │
│                                                      │
│  ┌─ 락 없음 ──────────┐  ┌─ Redis 분산 락 ────────┐ │
│  │ 성공: 73명 ❌초과!  │  │ 성공: 50명 ✅정확!    │ │
│  │ 서버1: 28명 처리    │  │ 서버1: 17명 처리      │ │
│  │ 서버2: 24명 처리    │  │ 서버2: 18명 처리      │ │
│  │ 서버3: 21명 처리    │  │ 서버3: 15명 처리      │ │
│  │ Race Condition!     │  │ Atomic 카운터 정상    │ │
│  └────────────────────┘  └────────────────────────┘ │
│                                                      │
│  ┌─ 실시간 카운터 ─────────────────────────┐         │
│  │ 잔여석: [██████████░░░░░░░░░░] 12/50   │         │
│  │ 대기열: 488명 → 처리중...               │         │
│  └─────────────────────────────────────────┘         │
│                                                      │
│  [시뮬레이션 속도: 느리게 ──●── 빠르게]               │
└─────────────────────────────────────────────────────┘
```

**핵심 학습 포인트:**
- Race Condition이 발생하면 정원 초과되는 것을 직접 목격
- 분산 락/Atomic 연산의 필요성을 시각적으로 증명

---

#### 문제 6: 교내 멘토링 1:1 실시간 채팅

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [실시간 채팅 시뮬레이터]                              │
│                                                      │
│  ┌─ 멘토 (서버1) ──┐    ┌─ 멘티 (서버2) ──┐         │
│  │ [채팅창]         │    │ [채팅창]         │         │
│  │ 안녕하세요!      │ ←→ │ 안녕하세요!      │         │
│  │ [메시지 입력___] │    │ [메시지 입력___] │         │
│  └──────────────────┘    └──────────────────┘        │
│                                                      │
│  ┌─ 메시지 라우팅 시각화 ──────────────────┐         │
│  │ 멘토 → WS서버1 → Redis Pub/Sub → WS서버2 → 멘티 │
│  │            ↓          [구독채널]          ↓       │
│  │         DB 저장       메시지 전파      DB 저장    │
│  └──────────────────────────────────────────┘        │
│                                                      │
│  [서버2 장애 시뮬레이션 ▶] → 오프라인 메시지 저장     │
│  [서버 재접속 ▶] → 밀린 메시지 수신                   │
└─────────────────────────────────────────────────────┘
```

---

#### 문제 7: 동아리 통합 공지 뉴스피드

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [뉴스피드 전략 시뮬레이터]                            │
│                                                      │
│  [Pull 모델]          vs          [Push (Fan-out)]   │
│                                                      │
│  ┌─ Pull (읽을 때 조회) ─┐  ┌─ Push (쓸 때 배포) ──┐│
│  │ 피드 로딩: 850ms     │  │ 피드 로딩: 15ms      ││
│  │ DB Join: 12테이블    │  │ Cache 조회: 1건      ││
│  │ DB 부하: ████ 높음   │  │ DB 부하: █░ 낮음     ││
│  │ 쓰기 속도: 5ms       │  │ 쓰기 속도: 120ms     ││
│  └──────────────────────┘  └──────────────────────┘ │
│                                                      │
│  [새 공지 작성 ▶] → Fan-out 과정 시각화              │
│  │                                                   │
│  │  작성자 → Feed Service → 가입자 500명 캐시 업데이트│
│  │          ████████████░░░░░░░░ 62% (310/500)      │
└─────────────────────────────────────────────────────┘
```

---

#### 문제 8: 도서관 도서 검색 자동완성

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [자동완성 검색 시뮬레이터]                            │
│                                                      │
│  검색: [해리____]                                     │
│                                                      │
│  ┌─ Trie 엔진 (50ms) ──┐  ┌─ DB LIKE (350ms) ────┐ │
│  │ ✓ 해리포터와 마법사  │  │ ✓ 해리포터와 마법사  │ │
│  │ ✓ 해리포터와 비밀의  │  │ ✓ 해리포터와 비밀의  │ │
│  │ ✓ 해리엇 스파이      │  │ ... 로딩중...        │ │
│  │ 응답: 8ms ⚡         │  │ 응답: 340ms 🐢       │ │
│  └──────────────────────┘  └──────────────────────┘ │
│                                                      │
│  ┌─ Trie 자료구조 시각화 ──────────────────┐         │
│  │         [해]                             │         │
│  │        /    \                            │         │
│  │     [리]    [양]                         │         │
│  │      |       |                          │         │
│  │   [포터]   [조]                         │         │
│  │    / \      |                           │         │
│  │ [와] [...]  [명]                        │         │
│  └─────────────────────────────────────────┘         │
│                                                      │
│  타이핑마다 검색 실행 횟수: [디바운스 없음: 12회]      │
│                              [디바운스 300ms: 3회]    │
└─────────────────────────────────────────────────────┘
```

---

#### 문제 9: 셔틀버스 실시간 위치 추적

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [실시간 위치 추적 시뮬레이터]                         │
│                                                      │
│  ┌─ 미니맵 (Canvas) ──────────────────────┐          │
│  │    🚌─ ─ ─ ─→ 🚌                       │          │
│  │   버스1(3초마다 위치 전송)               │          │
│  │        🚌── ─ ─→                        │          │
│  │       버스2                              │          │
│  └─────────────────────────────────────────┘         │
│                                                      │
│  ┌─ Write 부하 메트릭 ────────────────────┐          │
│  │ Redis (In-memory): 0.2ms/write ⚡      │          │
│  │ RDBMS (Disk):      45ms/write 🐢      │          │
│  │ 버스 10대 × 3초 = 3.3 writes/sec      │          │
│  │ 버스 100대 × 3초 = 33 writes/sec      │          │
│  └─────────────────────────────────────────┘         │
│                                                      │
│  [버스 수 조절: 10 ──●────── 1000]                   │
│  → 임계점에서 RDBMS가 감당 못하는 순간 시각화         │
└─────────────────────────────────────────────────────┘
```

---

#### 문제 10: 취업 공고 통합 크롤러

**시뮬레이션 화면 구성:**
```
┌─────────────────────────────────────────────────────┐
│  [분산 크롤러 시뮬레이터]                              │
│                                                      │
│  ┌─ Task Queue ──┐  ┌─ Workers ──────────────┐      │
│  │ ████████░░░░  │→ │ Worker1: crawling...   │      │
│  │ 대기: 847건   │→ │ Worker2: crawling...   │      │
│  │ 완료: 153건   │→ │ Worker3: idle          │      │
│  └───────────────┘  └────────────────────────┘      │
│                                                      │
│  ┌─ Bloom Filter 시각화 ──────────────────┐          │
│  │ [00100101001110010100010110...]          │          │
│  │ URL: job/123 → hash → bit[3,7,12] = ✓  │          │
│  │ 판정: 이미 방문함 (중복!) → Skip        │          │
│  │                                          │          │
│  │ 메모리 사용: 1.2MB (10만 URL 관리)       │          │
│  │ DB로 체크 시: 450MB + 쿼리 비용          │          │
│  └──────────────────────────────────────────┘        │
│                                                      │
│  ⚠️ False Positive Rate: 0.1%                        │
│  [Worker 수 조절: 1 ──●────── 10]                    │
└─────────────────────────────────────────────────────┘
```

---

## 4. 기술 구현 방안

### 4.1 파일 구조 (신규)

```
frontend/src/features/practice/
├── simulation/
│   ├── SimulationLauncher.vue          # 시뮬레이션 실행 버튼 UI
│   ├── SimulationGenerator.js          # HTML 코드 생성 엔진
│   ├── templates/
│   │   ├── base.html.js                # 공통 HTML 골격 (Tailwind CDN, 차트 라이브러리)
│   │   ├── urlShortener.html.js        # 문제1 시뮬레이션 템플릿
│   │   ├── pastebin.html.js            # 문제2
│   │   ├── notification.html.js        # 문제3
│   │   ├── imageFeed.html.js           # 문제4
│   │   ├── concurrency.html.js         # 문제5
│   │   ├── realtimeChat.html.js        # 문제6
│   │   ├── newsfeed.html.js            # 문제7
│   │   ├── autocomplete.html.js        # 문제8
│   │   ├── geolocation.html.js         # 문제9
│   │   └── webcrawler.html.js          # 문제10
│   └── utils/
│       ├── simulationMetrics.js        # 메트릭 시뮬레이션 로직
│       └── animationHelpers.js         # 데이터 흐름 애니메이션 유틸
```

### 4.2 SimulationGenerator 핵심 로직

```javascript
// SimulationGenerator.js 핵심 구조
export function generateSimulation(problemId, userComponents, userConnections) {
  // 1. 사용자가 배치한 컴포넌트 분석
  const hasCache = userComponents.some(c => c.type === 'cache');
  const hasQueue = userComponents.some(c => c.type === 'broker');
  const hasLB = userComponents.some(c => c.type === 'loadbalancer');

  // 2. 문제별 템플릿 선택
  const template = getTemplate(problemId);

  // 3. 사용자 설계 반영 (있는 컴포넌트만 활성화)
  const customizedHtml = template.generate({
    components: userComponents,
    connections: userConnections,
    features: { hasCache, hasQueue, hasLB }
  });

  // 4. Blob URL로 새 창 열기
  const blob = new Blob([customizedHtml], { type: 'text/html' });
  const url = URL.createObjectURL(blob);
  window.open(url, `sim_${problemId}`, 'width=1280,height=800');
}
```

### 4.3 공통 템플릿 기반 구조 (base.html.js)

```javascript
export function wrapWithBase(title, bodyContent, scripts) {
  return `<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>${title} - Architecture Simulator</title>
  <script src="https://cdn.tailwindcss.com"><\/script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"><\/script>
  <style>
    body { background: #0f172a; color: #e2e8f0; font-family: 'Rajdhani', sans-serif; }
    .metric-card { background: rgba(30,41,59,0.8); border: 1px solid #334155; border-radius: 12px; }
    .glow { box-shadow: 0 0 20px rgba(56,189,248,0.3); }
    @keyframes flow { 0%{transform:translateX(0)} 100%{transform:translateX(100px)} }
    .data-flow { animation: flow 1s ease-in-out infinite; }
  </style>
</head>
<body class="min-h-screen p-6">
  <div class="max-w-6xl mx-auto">
    <h1 class="text-2xl font-bold text-cyan-400 mb-6">${title}</h1>
    ${bodyContent}
  </div>
  <script>${scripts}<\/script>
</body>
</html>`;
}
```

### 4.4 시뮬레이션 연동 포인트

기존 `SystemArchitecturePractice.vue`의 GameHeader 영역에 시뮬레이션 버튼 추가:

```vue
<!-- GameHeader에 추가 -->
<button
  @click="launchSimulation"
  class="sim-button"
  :disabled="droppedComponents.length === 0"
>
  🚀 내 설계 테스트하기
</button>
```

### 4.5 사용자 설계 반영 로직

사용자가 캐시를 배치하지 않은 경우 → 시뮬레이션에서 캐시 없는 버전을 보여주고, 성능 차이를 강조:

```javascript
// 예: URL Shortener 시뮬레이션
if (!features.hasCache) {
  // 모든 요청이 DB로 직접 가는 시나리오 시각화
  // "만약 여기에 Cache를 추가하면?" 힌트 표시
  showComparison({
    current: { label: '현재 설계 (캐시 없음)', avgLatency: '230ms', dbLoad: '100%' },
    improved: { label: '캐시 추가 시', avgLatency: '45ms', dbLoad: '18%' }
  });
}
```

---

## 5. LLM 연동 고도화 (선택적 확장)

### 5.1 LLM 기반 커스텀 시뮬레이션 코드 생성

사용자가 표준 템플릿 외의 독창적인 설계를 했을 때, LLM이 맞춤형 시뮬레이션 코드를 생성:

```javascript
async function generateCustomSimulation(problem, components, connections, explanation) {
  const prompt = `다음 아키텍처 설계를 시뮬레이션하는 standalone HTML을 생성하세요.

  문제: ${problem.title}
  컴포넌트: ${JSON.stringify(components)}
  연결: ${JSON.stringify(connections)}
  설명: ${explanation}

  요구사항:
  - 단일 HTML 파일 (Tailwind CDN 사용)
  - 각 컴포넌트를 시각적 박스로 표현
  - 데이터 흐름 애니메이션
  - 부하 테스트 버튼
  - 실시간 메트릭 (응답시간, 처리량)
  - setTimeout으로 시뮬레이션된 지연시간 적용`;

  const html = await callOpenAI(prompt, { maxTokens: 4000 });
  return html;
}
```

### 5.2 주의사항
- LLM 생성 코드는 **보안 샌드박스**(iframe sandbox 속성)에서 실행
- 네트워크 요청 차단 (`sandbox="allow-scripts"`, `allow-same-origin` 제외)
- 생성 실패 시 기본 템플릿으로 폴백

---

## 6. 평가 시스템 연동

### 6.1 시뮬레이션 결과 → 평가 반영

시뮬레이션에서 수집된 메트릭을 평가에 활용:

```javascript
// 시뮬레이션 결과를 부모 창으로 전달
// (새 창에서)
window.opener.postMessage({
  type: 'SIMULATION_RESULT',
  metrics: {
    avgResponseTime: 45,
    cacheHitRate: 0.82,
    failureRate: 0.001,
    throughput: 950
  },
  userActions: ['load-test-1000', 'toggle-cache-off', 'toggle-cache-on']
}, '*');
```

```javascript
// (기존 프랙티스 창에서)
window.addEventListener('message', (event) => {
  if (event.data.type === 'SIMULATION_RESULT') {
    // 시뮬레이션 메트릭을 평가 컨텍스트에 추가
    evaluationContext.simulationMetrics = event.data.metrics;
  }
});
```

### 6.2 시뮬레이션 기반 추가 질문

시뮬레이션 결과를 바탕으로 더 깊은 질문 생성:

> "시뮬레이션에서 캐시 적중률이 82%였습니다. 나머지 18%의 캐시 미스는 어떤 상황에서 발생하며, 적중률을 95%까지 높이려면 어떤 전략을 쓸 수 있을까요?"

---

## 7. 구현 우선순위

### Phase 1: MVP (핵심 3개 문제)
- [ ] `SimulationGenerator.js` 기본 프레임워크
- [ ] `base.html.js` 공통 템플릿
- [ ] 문제 1 (URL Shortener) - 캐시 Hit/Miss 시뮬레이션
- [ ] 문제 3 (알림 시스템) - 동기 vs 비동기 비교
- [ ] 문제 5 (수강신청) - Race Condition 시뮬레이션
- [ ] `SystemArchitecturePractice.vue`에 시뮬레이션 버튼 통합

**선정 이유:** 캐시, 메시지큐, 동시성 제어 - 아키텍처 핵심 개념 3가지를 커버

### Phase 2: 확장 (나머지 7개)
- [ ] 문제 2 (Pastebin) - 저장소 분리 비용 비교
- [ ] 문제 4 (이미지 피드) - CDN 지연시간 비교
- [ ] 문제 6 (채팅) - WebSocket + Pub/Sub 시각화
- [ ] 문제 7 (뉴스피드) - Fan-out 전략 비교
- [ ] 문제 8 (자동완성) - Trie vs DB LIKE 성능 비교
- [ ] 문제 9 (위치추적) - Write-Heavy 부하 시각화
- [ ] 문제 10 (크롤러) - Bloom Filter 동작 시각화

### Phase 3: 고급 기능
- [ ] LLM 기반 커스텀 시뮬레이션 생성
- [ ] 시뮬레이션 메트릭 → 평가 시스템 연동
- [ ] 시뮬레이션 결과 기반 추가 질문 생성
- [ ] 시뮬레이션 히스토리 저장 (Django 백엔드)

---

## 8. 기술적 고려사항

### 8.1 성능
- Blob URL은 사용 후 `revokeObjectURL`로 해제 필요
- 시뮬레이션 내 `setInterval`은 창 닫힘 시 자동 정리
- Canvas 기반 애니메이션은 `requestAnimationFrame` 사용

### 8.2 보안
- LLM 생성 코드는 iframe sandbox 내에서 실행
- `postMessage`는 origin 검증 필수
- 외부 라이브러리는 CDN (Tailwind, Chart.js)만 허용

### 8.3 UX
- 시뮬레이션 로딩 중 스켈레톤 UI 표시
- 새 창 팝업 차단 시 안내 메시지
- 모바일에서는 시뮬레이션 축소 레이아웃 제공
- 시뮬레이션 내 "설계 화면으로 돌아가기" 버튼

### 8.4 기존 코드 활용
- **Monaco Editor**: 시뮬레이션 코드 직접 편집 모드 (고급 사용자용)
- **Mermaid**: 시뮬레이션 내에서도 아키텍처 다이어그램 표시
- **useCanvasState**: 컴포넌트/연결 데이터를 시뮬레이션에 전달
- **useEvaluation**: 시뮬레이션 메트릭을 평가 파이프라인에 통합

---

## 9. 기대 효과

| 항목 | 현재 | 고도화 후 |
|------|------|-----------|
| 학습 방식 | 이론 → 설계 → 텍스트 피드백 | 이론 → 설계 → **체험** → 피드백 |
| 실패 학습 | 텍스트로 "이것이 문제입니다" | **직접 Race Condition 목격, 서버 과부하 체감** |
| 설계 검증 | LLM 평가에 의존 | LLM 평가 + **시뮬레이션 메트릭 근거** |
| 몰입도 | 다이어그램 그리기로 제한 | 게임화 + 인터랙티브 시뮬레이션 |
| 차별화 | 일반적인 아키텍처 학습 도구 | **설계→시뮬레이션→검증 통합 플랫폼** |

---

## 10. 결론

이 고도화의 핵심 가치는 **"설계한 아키텍처가 실제로 어떻게 동작하는지 눈으로 확인"**하게 하는 것이다. 추상적 다이어그램 → 동작하는 프로토타입으로의 전환은 학습 깊이를 근본적으로 바꾼다.

Blob URL 기반 새 창 렌더링 방식은 별도 서버 없이 프론트엔드만으로 구현 가능하며, 문제별 템플릿을 점진적으로 추가할 수 있어 현실적인 구현 경로를 제공한다.
