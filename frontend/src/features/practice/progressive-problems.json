{
  "progressiveProblems": [
    {
      "id": "P1",
      "project_title": "ì •í™•ë„ê°€ ë¹„ì •ìƒì ìœ¼ë¡œ ë†’ì€ ë¶„ë¥˜ ëª¨ë¸",
      "scenario": "ì‚¬ìš©ì ì´íƒˆ ì—¬ë¶€ë¥¼ ì˜ˆì¸¡í•˜ëŠ” ë¶„ë¥˜ ëª¨ë¸ì„ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤. í•™ìŠµì€ ì •ìƒì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆê³  ì •í™•ë„ë„ ë†’ê²Œ ë‚˜ì˜¤ì§€ë§Œ, ì‹¤ì œ ì„œë¹„ìŠ¤ì—ì„œëŠ” ì˜ˆì¸¡ì´ ê±°ì˜ ë¬´ì‘ìœ„ì— ê°€ê¹ë‹¤ëŠ” ë¬¸ì œê°€ ë³´ê³ ë˜ì—ˆìŠµë‹ˆë‹¤.",
      "difficulty": 1,
      "totalSteps": 3,
      "steps": [
        {
          "step": 1,
          "title": "Train/Test ë°ì´í„° ëˆ„ìˆ˜ (Data Leakage)",
          "bug_type": "A",
          "bug_type_name": "Data Leakage",
          "questions": {
            "text": "ëª¨ë¸ ì •í™•ë„ê°€ 0.98ë¡œ ë§¤ìš° ë†’ê²Œ ë‚˜ì˜¤ëŠ”ë° ì‹¤ì œ ì„±ëŠ¥ì´ ë‚®ë‹¤ë©´, ê°€ì¥ ë¨¼ì € ì˜ì‹¬í•´ì•¼ í•  ì›ì¸ì€?",
            "options": [
              "ëª¨ë¸ êµ¬ì¡°ê°€ ë„ˆë¬´ ë‹¨ìˆœí•´ì„œ",
              "í…ŒìŠ¤íŠ¸ ë°ì´í„° ì •ë³´ê°€ í•™ìŠµ ê³¼ì •ì— í¬í•¨ë˜ì—ˆì„ ê°€ëŠ¥ì„±",
              "í•™ìŠµ íšŸìˆ˜(epoch)ê°€ ë„ˆë¬´ ì ì–´ì„œ",
              "ë°ì´í„° ì–‘ì´ ë¶€ì¡±í•´ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "from sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\n\ndef prepare_data(df):\n    X = df.drop('churn', axis=1)\n    y = df['churn']\n    \n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=42\n    )\n    \n    scaler = StandardScaler()\n    X_train = scaler.fit_transform(X)\n    X_test = scaler.transform(X_test)\n    return X_train, X_test, y_train, y_test",
          "correct_code": "from sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\n\ndef prepare_data(df):\n    X = df.drop('churn', axis=1)\n    y = df['churn']\n    \n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=42\n    )\n    \n    scaler = StandardScaler()\n    X_train = scaler.fit_transform(X_train)\n    X_test = scaler.transform(X_test)\n    return X_train, X_test, y_train, y_test",
          "hint": "scaler.fit_transform(X)ë¥¼ ì „ì²´ ë°ì´í„°ë¡œ í•˜ë©´ test ì •ë³´ê°€ í•™ìŠµì— í¬í•¨ë©ë‹ˆë‹¤.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "fit_transform(X_train)"
            ],
            "forbidden": [
              "fit_transform(X)"
            ]
          },
          "coaching": "ğŸ¯ í˜„ì—…: Data LeakageëŠ” ëª¨ë¸ì´ 'ë„ˆë¬´ ì˜ ë‚˜ì˜¬ ë•Œ' ì˜ì‹¬í•´ì•¼ í•˜ëŠ” 1ìˆœìœ„ ë²„ê·¸ì…ë‹ˆë‹¤. ì „ì²˜ë¦¬ëŠ” ë°˜ë“œì‹œ train/test ë¶„í•  í›„ì— í•´ì•¼ í•©ë‹ˆë‹¤."
        },
        {
          "step": 2,
          "title": "í‰ê°€ ì§€í‘œ ê³„ì‚° ëŒ€ìƒ ì˜¤ë¥˜",
          "bug_type": "B",
          "bug_type_name": "Metric Misuse",
          "questions": {
            "text": "accuracyê°€ 1.0ìœ¼ë¡œ ë‚˜ì™€ ì‹ ë¢°í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤. ê°€ì¥ ê°€ëŠ¥ì„±ì´ ë†’ì€ ì´ìœ ëŠ”?",
            "options": [
              "ì •í™•ë„ëŠ” ë¶„ë¥˜ ë¬¸ì œì— ì í•©í•˜ì§€ ì•Šì•„ì„œ",
              "ëª¨ë¸ì´ ë„ˆë¬´ ë³µì¡í•´ì„œ",
              "ì˜ˆì¸¡ê°’ì„ ìê¸° ìì‹ ê³¼ ë¹„êµí–ˆê¸° ë•Œë¬¸ì—",
              "ë‚œìˆ˜ ì‹œë“œë¥¼ ê³ ì •í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—"
            ],
            "answer": 2
          },
          "buggy_code": "from sklearn.metrics import accuracy_score\n\ndef evaluate(model, X_test, y_test, y_pred):\n    accuracy = accuracy_score(y_pred, y_pred)\n    return accuracy",
          "correct_code": "from sklearn.metrics import accuracy_score\n\ndef evaluate(model, X_test, y_test, y_pred):\n    accuracy = accuracy_score(y_test, y_pred)\n    return accuracy",
          "hint": "accuracy_scoreëŠ” 'ì •ë‹µ'ê³¼ 'ì˜ˆì¸¡'ì„ ë¹„êµí•´ì•¼ í•©ë‹ˆë‹¤. ê°™ì€ ê°’ë¼ë¦¬ ë¹„êµí•˜ë©´ í•­ìƒ 1.0ì´ ë‚˜ì˜µë‹ˆë‹¤.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "accuracy_score(y_test, y_pred)"
            ],
            "forbidden": [
              "accuracy_score(y_pred, y_pred)",
              "accuracy_score(y_train"
            ]
          },
          "coaching": "ğŸ¯ í˜„ì—…: í‰ê°€ ì§€í‘œëŠ” í•­ìƒ 'ì •ë‹µ vs ì˜ˆì¸¡'ì„ ë¹„êµí•©ë‹ˆë‹¤. ê°™ì€ ê°’ë¼ë¦¬ ë¹„êµí•˜ëŠ” ì‹¤ìˆ˜ëŠ” ì´ˆë³´ìê°€ ê°€ì¥ ë§ì´ í•˜ëŠ” ì‹¤ìˆ˜ì…ë‹ˆë‹¤."
        },
        {
          "step": 3,
          "title": "ë¼ë²¨ ì¸ì½”ë”© ì¬ì‚¬ìš© ì˜¤ë¥˜",
          "bug_type": "C",
          "bug_type_name": "Encoding Drift",
          "questions": {
            "text": "ë¼ë²¨ ì¸ì½”ë”©ì„ train/testì— ê°ê° ë”°ë¡œ fití•˜ë©´ ì–´ë–¤ ë¬¸ì œê°€ ìƒê¸¸ê¹Œìš”?",
            "options": [
              "trainê³¼ testì˜ ë¼ë²¨ ìˆ«ì ì˜ë¯¸ê°€ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆë‹¤",
              "í•™ìŠµ ì†ë„ê°€ ëŠë ¤ì§„ë‹¤",
              "ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì´ ì¦ê°€í•œë‹¤",
              "ëª¨ë¸ êµ¬ì¡°ê°€ ìë™ìœ¼ë¡œ ë³€ê²½ëœë‹¤"
            ],
            "answer": 0
          },
          "buggy_code": "from sklearn.preprocessing import LabelEncoder\n\ndef encode_labels(y_train, y_test):\n    le = LabelEncoder()\n    y_train = le.fit_transform(y_train)\n    y_test = le.fit_transform(y_test)\n    return y_train, y_test",
          "correct_code": "from sklearn.preprocessing import LabelEncoder\n\ndef encode_labels(y_train, y_test):\n    le = LabelEncoder()\n    y_train = le.fit_transform(y_train)\n    y_test = le.transform(y_test)\n    return y_train, y_test",
          "hint": "ì¸ì½”ë”© ê¸°ì¤€ì€ trainìœ¼ë¡œë§Œ ë§Œë“¤ê³ , testì—ëŠ” ê·¸ ê¸°ì¤€ì„ ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "y_test = le.transform(y_test)"
            ],
            "forbidden": [
              "fit_transform(y_test)",
              "fit(y_test)"
            ]
          },
          "coaching": "ğŸ¯ í˜„ì—…: ì¸ì½”ë”© ê¸°ì¤€ì´ ë‹¬ë¼ì§€ë©´ ëª¨ë¸ì€ ì™„ì „íˆ ë‹¤ë¥¸ ì˜ë¯¸ì˜ ìˆ«ìë¥¼ í•™ìŠµ/í‰ê°€í•˜ê²Œ ë©ë‹ˆë‹¤. ì „ì²˜ë¦¬ ê°ì²´ëŠ” í•­ìƒ ì €ì¥í•´ì„œ ì¬ì‚¬ìš©í•˜ì„¸ìš”."
        }
      ]
    },
    {
      "id": "P2",
      "project_title": "ë°ì´í„° ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ ê¸°ë³¸ ë°©ì–´",
      "scenario": "ì‚¬ìš©ì í–‰ë™ ë¡œê·¸ë¡œ ì´íƒˆ ì˜ˆì¸¡ ëª¨ë¸ì„ í•™ìŠµí•˜ê³  ìˆìŠµë‹ˆë‹¤. ì „ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ì´ ì¢…ì¢… ì˜ˆì™¸ë¡œ í„°ì§€ê±°ë‚˜, í•™ìŠµì´ 'ë˜ëŠ” ê²ƒì²˜ëŸ¼' ë³´ì´ì§€ë§Œ ê²°ê³¼ê°€ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤.",
      "difficulty": 2,
      "totalSteps": 3,
      "steps": [
        {
          "step": 1,
          "title": "ê²°ì¸¡ì¹˜ ì²˜ë¦¬ ëˆ„ë½ (NaN Handling)",
          "bug_type": "A",
          "bug_type_name": "Null Handling",
          "questions": {
            "text": "ëª¨ë¸ í•™ìŠµ ì§ì „ì— 'Input contains NaN' ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê°€ì¥ ê°€ëŠ¥ì„±ì´ ë†’ì€ ì›ì¸ì€?",
            "options": [
              "í•™ìŠµ ë°ì´í„°ê°€ ë„ˆë¬´ ì»¤ì„œ",
              "ì „ì²˜ë¦¬ ê³¼ì •ì—ì„œ ê²°ì¸¡ì¹˜(NaN)ê°€ ë‚¨ì•„ ìˆì–´ì„œ",
              "ëª¨ë¸ì´ ë„ˆë¬´ ë‹¨ìˆœí•´ì„œ",
              "ì •ê·œí™”ë¥¼ í•´ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "import pandas as pd\n\ndef preprocess(df):\n    df = df.copy()\n    df['age'] = df['age'].astype(int)\n    return df",
          "correct_code": "import pandas as pd\n\ndef preprocess(df):\n    df = df.copy()\n    df['age'] = df['age'].fillna(0).astype(int)\n    return df",
          "hint": "NaNì´ ìˆìœ¼ë©´ astype()ì´ ì‹¤íŒ¨í•©ë‹ˆë‹¤. ê²°ì¸¡ì¹˜ë¥¼ ì²˜ë¦¬í•˜ì„¸ìš”.",
          "solution_check": {
            "type": "regex",
            "value": "(fillna\\(\\s*(0)?\\s*\\)|dropna\\(\\s*\\))",
            "flags": ""
          },
          "coaching": "ğŸ¯ í˜„ì—…: ì‹¤ë¬´ ë°ì´í„°ëŠ” í•­ìƒ ê²°ì¸¡ì¹˜ë¥¼ í¬í•¨í•©ë‹ˆë‹¤. fillna(0), fillna(í‰ê· ), fillna(ì¤‘ì•™ê°’) ì¤‘ ë„ë©”ì¸ì— ë§ëŠ” ì „ëµì„ ì„ íƒí•˜ì„¸ìš”."
        },
        {
          "step": 2,
          "title": "0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì–´ (Zero Division Guard)",
          "bug_type": "B",
          "bug_type_name": "Null Guard",
          "questions": {
            "text": "ì‚¬ìš©ìë³„ í‰ê·  êµ¬ë§¤ì•¡ ê³„ì‚° ì‹œ 'division by zero' ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì–´ë–¤ ìƒí™©ì¼ê¹Œìš”?",
            "options": [
              "êµ¬ë§¤ì•¡ì´ ë„ˆë¬´ ì»¤ì„œ",
              "íŠ¹ì • ì‚¬ìš©ìì˜ êµ¬ë§¤ íšŸìˆ˜(count)ê°€ 0ì´ì–´ì„œ",
              "CSV ì¸ì½”ë”©ì´ ê¹¨ì ¸ì„œ",
              "ë°ì´í„°ê°€ ë„ˆë¬´ ì ì–´ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "def avg_spend(total_spend, count):\n    return total_spend / count",
          "correct_code": "def avg_spend(total_spend, count):\n    if count == 0:\n        return 0\n    return total_spend / count",
          "hint": "countê°€ 0ì¼ ë•Œë¥¼ ë°©ì–´í•´ì•¼ í•©ë‹ˆë‹¤.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "if count == 0"
            ],
            "forbidden": []
          },
          "coaching": "ğŸ¯ í˜„ì—…: ì‹ ê·œ ê°€ì…ìë‚˜ ë¹„í™œì„± ì‚¬ìš©ìëŠ” countê°€ 0ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°©ì–´ ì½”ë“œëŠ” ì„ íƒì´ ì•„ë‹ˆë¼ í•„ìˆ˜ì…ë‹ˆë‹¤."
        },
        {
          "step": 3,
          "title": "ì›ë³¸ ë°ì´í„° ë³´ì¡´ (State Leak)",
          "bug_type": "C",
          "bug_type_name": "State Leak",
          "questions": {
            "text": "ì „ì²˜ë¦¬ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œ ë’¤ ì›ë³¸ ë°ì´í„°í”„ë ˆì„ê¹Œì§€ í•¨ê»˜ ë°”ë€Œì—ˆìŠµë‹ˆë‹¤. ì™œì¼ê¹Œìš”?",
            "options": [
              "ë©”ëª¨ë¦¬ê°€ ë¶€ì¡±í•´ì„œ",
              "ë°ì´í„°í”„ë ˆì„ì´ ì°¸ì¡°ë¡œ ì „ë‹¬ë˜ì–´ ì›ë³¸ì´ ìˆ˜ì •ë˜ì—ˆê¸° ë•Œë¬¸ì—",
              "Pandas ë²„ê·¸ë¼ì„œ",
              "ì „ì—­ ë³€ìˆ˜ê°€ ìë™ ìƒì„±ë˜ì–´ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "def add_feature(df):\n    df['is_vip'] = df['spend'] > 100\n    return df",
          "correct_code": "def add_feature(df):\n    df = df.copy()\n    df['is_vip'] = df['spend'] > 100\n    return df",
          "hint": "DataFrameì€ ì°¸ì¡°ë¡œ ì „ë‹¬ë˜ë¯€ë¡œ ì›ë³¸ì´ ìˆ˜ì •ë©ë‹ˆë‹¤. ë³µì‚¬ë³¸ì„ ë§Œë“¤ì–´ ì‘ì—…í•˜ì„¸ìš”.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              ".copy()"
            ],
            "forbidden": [
              "inplace=True"
            ]
          },
          "coaching": "ğŸ¯ í˜„ì—…: State LeakëŠ” ì¬í˜„ ë¶ˆê°€ëŠ¥í•œ ë²„ê·¸ì˜ ì£¼ìš” ì›ì¸ì…ë‹ˆë‹¤. í•¨ìˆ˜ëŠ” ì…ë ¥ì„ ë³€ê²½í•˜ì§€ ì•Šê³  ìƒˆë¡œìš´ ê°ì²´ë¥¼ ë°˜í™˜í•˜ì„¸ìš”."
        }
      ]
    },
    {
      "id": "P3",
      "project_title": "í‰ê°€ íŒŒì´í”„ë¼ì¸ ì‹ ë¢°ì„± í™•ë³´",
      "scenario": "ì´íƒˆ ì˜ˆì¸¡ ëª¨ë¸ì„ ë°°í¬í•˜ê¸° ì „ ì„±ëŠ¥ ë¦¬í¬íŠ¸ë¥¼ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤. ê·¸ëŸ°ë° ë¦¬í¬íŠ¸ ìˆ˜ì¹˜ê°€ ê³¼ë„í•˜ê²Œ ì¢‹ê±°ë‚˜, ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ê²°ê³¼ê°€ ë‹¬ë¼ì§‘ë‹ˆë‹¤.",
      "difficulty": 3,
      "totalSteps": 3,
      "steps": [
        {
          "step": 1,
          "title": "ë¶ˆê· í˜• ë°ì´í„° ë¶„í•  ì˜¤ë¥˜ (Stratify ëˆ„ë½)",
          "bug_type": "A",
          "bug_type_name": "Sampling Bug",
          "questions": {
            "text": "ì´íƒˆë¥  5%ì¸ ë°ì´í„°ì—ì„œ ë§¤ë²ˆ í‰ê°€ ê²°ê³¼ê°€ í¬ê²Œ í”ë“¤ë¦½ë‹ˆë‹¤. ê°€ì¥ ë¨¼ì € ì˜ì‹¬í•´ì•¼ í•  ê²ƒì€?",
            "options": [
              "ëª¨ë¸ì´ ë„ˆë¬´ ë‹¨ìˆœí•´ì„œ",
              "train/test ë¶„í•  ì‹œ í´ë˜ìŠ¤ ë¹„ìœ¨ì´ ê¹¨ì¡Œì„ ê°€ëŠ¥ì„±",
              "ì „ì²˜ë¦¬ ì‹œê°„ì´ ë„ˆë¬´ ê¸¸ì–´ì„œ",
              "íŠ¹ì„±ì´ ë„ˆë¬´ ë§ì•„ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "from sklearn.model_selection import train_test_split\n\ndef split(df):\n    X = df.drop('churn', axis=1)\n    y = df['churn']\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=42\n    )\n    return X_train, X_test, y_train, y_test", 
          "correct_code": "from sklearn.model_selection import train_test_split\n\ndef split(df):\n    X = df.drop('churn', axis=1)\n    y = df['churn']\n    X_train, X_test, y_train, y_test = train_test_split(\n        X, y, test_size=0.2, random_state=42, stratify=y\n    )\n    return X_train, X_test, y_train, y_test",
          "hint": "ë°ì´í„°ê°€ ë¶ˆê· í˜•í•©ë‹ˆë‹¤. train_test_splitì˜ íŠ¹ì • íŒŒë¼ë¯¸í„°ë¥¼ í™œìš©í•´ y í´ë˜ìŠ¤ ë¹„ìœ¨ì„ ìœ ì§€í•˜ì„¸ìš”.",
          "solution_check": {
            "type": "regex",
            "value": "stratify\\s*=\\s*y\\s*(?=,\\s*\\w|\\))",
            "flags": ""
          },
          "coaching": "ğŸ¯ í˜„ì—…: ë¶ˆê· í˜• ë°ì´í„°(ì‚¬ê¸° íƒì§€, ì´íƒˆ ì˜ˆì¸¡)ì—ì„œ stratify ì—†ì´ splití•˜ë©´ testì— positive ìƒ˜í”Œì´ ê±°ì˜ ì—†ì–´ í‰ê°€ê°€ ë¬´ì˜ë¯¸í•´ì§‘ë‹ˆë‹¤."
        },
        {
          "step": 2,
          "title": "ì¬í˜„ì„±(Seed) ëˆ„ë½",
          "bug_type": "B",
          "bug_type_name": "Non-determinism",
          "questions": {
            "text": "ê°™ì€ ì½”ë“œë¡œ í•™ìŠµí–ˆëŠ”ë° ì‹¤í–‰í•  ë•Œë§ˆë‹¤ ì ìˆ˜ê°€ ë‹¤ë¦…ë‹ˆë‹¤. ê°€ì¥ ê·¸ëŸ´ë“¯í•œ ì›ì¸ì€?",
            "options": [
              "CPU ì„±ëŠ¥ì´ ë‹¬ë¼ì„œ",
              "ë‚œìˆ˜ ì‹œë“œê°€ ê³ ì •ë˜ì§€ ì•Šì•„ì„œ",
              "ë°ì´í„°ê°€ ë„ˆë¬´ ë§ì•„ì„œ",
              "ëª¨ë¸ì´ ë„ˆë¬´ ë‹¨ìˆœí•´ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "import numpy as np\nimport random\n\ndef train(model, X_train, y_train):\n    random.seed(42)\n    model.fit(X_train, y_train)\n    return model",
          "correct_code": "import numpy as np\nimport random\n\ndef train(model, X_train, y_train):\n    random.seed(42)\n    np.random.seed(42)\n    model.fit(X_train, y_train)\n    return model",
          "hint": "ê²°ê³¼ë¥¼ ì¬í˜„í•˜ë ¤ë©´ Numpyì˜ ë‚œìˆ˜ ì‹œë“œë¥¼ í•™ìŠµ ì „ì— ê³ ì •í•˜ì„¸ìš”.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "np.random.seed(",
              "random.seed("
            ],
            "forbidden": []
          },
          "coaching": "ğŸ¯ í˜„ì—…: ì¬í˜„ ë¶ˆê°€ëŠ¥í•˜ë©´ A/B í…ŒìŠ¤íŠ¸, ë””ë²„ê¹…, í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹ì´ ëª¨ë‘ ë¬´ì˜ë¯¸í•´ì§‘ë‹ˆë‹¤. ì‹œë“œ ê³ ì •ì€ í•„ìˆ˜ì…ë‹ˆë‹¤."
        },
        {
          "step": 3,
          "title": "ë¶ˆê· í˜• ë°ì´í„° ì§€í‘œ ì„ íƒ ì˜¤ë¥˜ (Accuracy í•¨ì •)",
          "bug_type": "C",
          "bug_type_name": "Metric Choice",
          "questions": {
            "text": "ì´íƒˆë¥  5%ì¸ ë°ì´í„°ì—ì„œ accuracy 95%ê°€ ë‚˜ì™”ì§€ë§Œ ì´íƒˆ ê³ ê°ì„ í•˜ë‚˜ë„ ëª» ì¡ìŠµë‹ˆë‹¤. ì´ìœ ëŠ”?",
            "options": [
              "accuracyê°€ ë¶ˆê· í˜• ë°ì´í„°ì—ì„œ ë‹¤ìˆ˜ í´ë˜ìŠ¤ì— í¸í–¥ë˜ì–´ ì˜¤í•´ë¥¼ ë§Œë“¤ ìˆ˜ ìˆì–´ì„œ",
              "ëª¨ë¸ì´ ë„ˆë¬´ ë³µì¡í•´ì„œ",
              "ë°ì´í„°ê°€ ë„ˆë¬´ ì»¤ì„œ",
              "ì „ì²˜ë¦¬ë¥¼ í•´ì„œ"
            ],
            "answer": 0
          },
          "buggy_code": "from sklearn.metrics import accuracy_score\n\ndef evaluate(model, X_test, y_test):\n    y_pred = model.predict(X_test)\n    return accuracy_score(y_test, y_pred)",
          "correct_code": "from sklearn.metrics import f1_score\n\ndef evaluate(model, X_test, y_test):\n    y_pred = model.predict(X_test)\n    return f1_score(y_test, y_pred)",
          "hint": "ë¶ˆê· í˜• ë°ì´í„°ì—ì„œëŠ” accuracy ëŒ€ì‹  ì¬í˜„ìœ¨ê³¼ ì •ë°€ë„ë¥¼ ëª¨ë‘ ê³ ë ¤í•˜ëŠ” ì§€í‘œë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [],
            "required_any": [
              "f1_score"
            ],
            "forbidden": [
              "accuracy_score"
            ]
          },
          "coaching": "ğŸ¯ í˜„ì—…: ëª¨ë“  ê²ƒì„ 'ìœ ì§€'ë¡œ ì˜ˆì¸¡í•´ë„ 95% accuracyê°€ ë‚˜ì˜µë‹ˆë‹¤. F1-scoreëŠ” recallê³¼ precisionê³¼ ì¡°í™”í‰ê· ìœ¼ë¡œ ë¶ˆê· í˜• ë°ì´í„°ì— ì í•©í•©ë‹ˆë‹¤."
        }
      ]
    },
    {
      "id": "P4",
      "project_title": "ë°°í¬ ì „ ë§ˆì§€ë§‰ í•¨ì • ì œê±°",
      "scenario": "ëª¨ë¸ì€ ì¶©ë¶„íˆ í•™ìŠµë˜ì—ˆê³  í‰ê°€ë„ í†µê³¼í–ˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ë°°í¬ ì§ì „ ì ê²€ì—ì„œ ìš´ì˜ í™˜ê²½ì—ì„œë§Œ í„°ì§€ëŠ” ë¬¸ì œê°€ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.",
      "difficulty": 4,
      "totalSteps": 3,
      "steps": [
        {
          "step": 1,
          "title": "í•™ìŠµ/ì„œë¹™ í”¼ì²˜ ë¶ˆì¼ì¹˜ (Feature Mismatch)",
          "bug_type": "A",
          "bug_type_name": "Schema Drift",
          "questions": {
            "text": "ì˜¤í”„ë¼ì¸ì—ì„œëŠ” í†µê³¼í–ˆëŠ”ë° ìš´ì˜ì—ì„œ 'Feature names mismatch' ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì›ì¸ì€?",
            "options": [
              "ëª¨ë¸ì´ ë„ˆë¬´ ì»¤ì„œ",
              "í•™ìŠµ ì‹œ ì‚¬ìš©í•œ í”¼ì²˜ ì»¬ëŸ¼ê³¼ ì„œë¹™ ì…ë ¥ ì»¬ëŸ¼ì˜ ìˆœì„œë‚˜ ê°œìˆ˜ê°€ ë‹¬ë¼ì„œ",
              "ë°ì´í„°ê°€ ë„ˆë¬´ ì ì–´ì„œ",
              "ë‚œìˆ˜ ì‹œë“œë¥¼ ê³ ì •í•´ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "def serve(model, input_df):\n    return model.predict(input_df)",
          "correct_code": "def serve(model, input_df, feature_cols):\n    X = input_df[feature_cols]\n    return model.predict(X)",
          "hint": "í•™ìŠµ ì‹œ ì‚¬ìš©í•œ feature ì»¬ëŸ¼ ë¦¬ìŠ¤íŠ¸ë¥¼ ì €ì¥í•´ë‘ê³ , ì„œë¹™ ì‹œ ê·¸ ì»¬ëŸ¼ë§Œ ì„ íƒí•´ì„œ ì‚¬ìš©í•˜ì„¸ìš”.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "input_df[feature_cols]"
            ],
            "forbidden": []
          },
          "coaching": "ğŸ¯ í˜„ì—…: Train-Serve SkewëŠ” ML ì‹œìŠ¤í…œ ì¥ì• ì˜ 70% ì´ìƒì„ ì°¨ì§€í•©ë‹ˆë‹¤. Feature ì»¬ëŸ¼ ë¦¬ìŠ¤íŠ¸ë¥¼ ëª¨ë¸ ë©”íƒ€ë°ì´í„°ë¡œ ì €ì¥í•˜ì„¸ìš”."
        },
        {
          "step": 2,
          "title": "ìƒˆë¡œìš´ ì¹´í…Œê³ ë¦¬ ì²˜ë¦¬ ëˆ„ë½ (Unseen Category)",
          "bug_type": "B",
          "bug_type_name": "Unseen Category",
          "questions": {
            "text": "ìš´ì˜ ë°ì´í„°ì— í•™ìŠµ ë•Œ ì—†ë˜ ì‹ ê·œ êµ­ê°€ ì½”ë“œê°€ ë“¤ì–´ì˜¤ë©´ì„œ ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì–´ë–¤ ë¬¸ì œì¼ê¹Œìš”?",
            "options": [
              "ì†ë„ê°€ ë¹¨ë¼ì§„ë‹¤",
              "ì¸ì½”ë”ê°€ í•™ìŠµ ì‹œ ë³´ì§€ ëª»í•œ ì¹´í…Œê³ ë¦¬ë¥¼ ì²˜ë¦¬í•˜ì§€ ëª»í•´ ì—ëŸ¬ë¥¼ ë‚¸ë‹¤",
              "ë©”ëª¨ë¦¬ê°€ ì¤„ì–´ë“ ë‹¤",
              "ì •í™•ë„ê°€ ìë™ìœ¼ë¡œ ì˜¬ë¼ê°„ë‹¤"
            ],
            "answer": 1
          },
          "buggy_code": "from sklearn.preprocessing import OneHotEncoder\n\ndef fit_encoder(train_cat):\n    enc = OneHotEncoder()\n    enc.fit(train_cat)\n    return enc",
          "correct_code": "from sklearn.preprocessing import OneHotEncoder\n\ndef fit_encoder(train_cat):\n    enc = OneHotEncoder(handle_unknown='ignore')\n    enc.fit(train_cat)\n    return enc",
          "hint": "OneHotEncoderì— handle_unknown='_ _ _ _ _ _' ì˜µì…˜ì„ ì„¤ì •í•˜ì„¸ìš”.",

          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "handle_unknown='ignore'"
            ],
            "forbidden": []
          },
          "coaching": "ğŸ¯ í˜„ì—…: ìš´ì˜ ë°ì´í„°ëŠ” í•­ìƒ í•™ìŠµ ë°ì´í„°ë³´ë‹¤ ë‹¤ì–‘í•©ë‹ˆë‹¤. ìƒˆ ìƒí’ˆ, ì‹ ê·œ êµ­ê°€ ë“±ì´ ê³„ì† ì¶”ê°€ë˜ë¯€ë¡œ ë°©ì–´ ì½”ë“œê°€ í•„ìˆ˜ì…ë‹ˆë‹¤."
        },
        {
          "step": 3,
          "title": "ì „ì²˜ë¦¬ê¸°/ëª¨ë¸ ë²ˆë“¤ ì €ì¥ ëˆ„ë½",
          "bug_type": "C",
          "bug_type_name": "Artifact Drift",
          "questions": {
            "text": "ëª¨ë¸ì„ ì¬ë°°í¬í–ˆëŠ”ë° ì„±ëŠ¥ì´ ê°‘ìê¸° ë‚˜ë¹ ì¡ŒìŠµë‹ˆë‹¤. ëª¨ë¸ ì½”ë“œëŠ” ì•ˆ ë°”ê¿¨ëŠ”ë° ì™œì¼ê¹Œìš”?",
            "options": [
              "ëª¨ë¸ì´ ìŠ¤ìŠ¤ë¡œ ë³€í•´ì„œ",
              "ì „ì²˜ë¦¬ê¸°ê°€ ì¬í•™ìŠµë˜ì–´ ì´ì „ê³¼ ë‹¤ë¥¸ ê¸°ì¤€ìœ¼ë¡œ ë³€í™˜í•˜ê¸° ë•Œë¬¸ì—",
              "CPUê°€ ëŠë ¤ì ¸ì„œ",
              "ë°ì´í„°ê°€ ì¤„ì–´ì„œ"
            ],
            "answer": 1
          },
          "buggy_code": "import joblib\n\ndef save_model(model, scaler, encoder, path):\n    joblib.dump(model, path)\n    return path",
          "correct_code": "import joblib\n\ndef save_model(model, scaler, encoder, path):\n    bundle = {\n        'model': model,\n        'scaler': scaler,\n        'encoder': encoder\n    }\n    joblib.dump(bundle, path)\n    return path",
          "hint": "ëª¨ë¸ë¿ ì•„ë‹ˆë¼ scaler, encoderë„ í•¨ê»˜ ì €ì¥í•´ì•¼ í•©ë‹ˆë‹¤. ë”•ì…”ë„ˆë¦¬ë¡œ ë¬¶ì–´ì„œ bundle í˜•íƒœë¡œ ë§Œë“  í›„ dumpí•˜ì„¸ìš”.",
          "solution_check": {
            "type": "multi_condition",
            "required_all": [
              "'model':",
              "'scaler':",
              "'encoder':"
            ],
            "forbidden": []
          },
          "coaching": "ğŸ¯ í˜„ì—…: ëª¨ë¸ë§Œ ì €ì¥í•˜ë©´ ì „ì²˜ë¦¬ ê¸°ì¤€ì´ ë‹¬ë¼ì ¸ì„œ ì„±ëŠ¥ì´ ë¬´ë„ˆì§‘ë‹ˆë‹¤. ëª¨ë¸+ì „ì²˜ë¦¬ê¸°ë¥¼ í•˜ë‚˜ì˜ ë²ˆë“¤ë¡œ ê´€ë¦¬í•˜ì„¸ìš”."
        }
      ]
    }
  ]
}